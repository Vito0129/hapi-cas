<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: plugin.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: plugin.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const debug = require('debug')('hapi-cas:main');
const CAS = require('simple-cas-interface');
const Hoek = require('hoek');
const Joi = require('joi');
const Boom = require('boom');

/**
 * &lt;p>Defines the possible options for the plugin.&lt;/p>
 *
 * @typedef {object} PluginOptions
 * @property {string} casServerUrl The URL for the remote CAS server. It
 *  &lt;em>should&lt;/em> be an HTTPS URL. But it &lt;em>can&lt;/em> be HTTP if the remote
 *  server isn't fully protocol compliant.
 *  Example: &lt;tt>https://example.com/cas/&lt;/tt>
 * @property {number} [casProtocolVersion=2.0] The version of the CAS protocol
 *  that the remote server implements.
 * @property {string} [casRequestMethod=GET] The HTTP method that the remote
 *  CAS server should use to communicate with the local CAS handler end point.
 *  &lt;strong>NOTE:&lt;/strong> only &lt;em>GET&lt;/em> is currently supported.
 * @property {boolean} [casAsGateway=false] Indicates if the remote CAS server
 *  should use its gateway method of operation.
 * @property {string} localAppUrl The base URL for your local applications. It
 *  &lt;em>should&lt;/em> be an HTTPS URL. But it &lt;em>can&lt;/em> be HTTP if the remote
 *  server isn't fully protocol compliant.
 *  Example: &lt;tt>https://app.example.com/&lt;/tt>
 * @property {string} endPointPath The URI path where your application will
 *  listen for incoming CAS protocol messages. Example: &lt;tt>/casHandler&lt;/tt>
 * @property {array} [includeHeaders=['cookie']] The headers to include in
 *  redirections. This list &lt;em>must&lt;/em> include the header your session
 *  manager uses for tracking session identifiers.
 * @property {boolean} [strictSSL=true] Determines if the client will require
 *  valid remote SSL certificates or not.
 * @property {boolean} [saveRawCAS=false] If true the CAS result will be
 *  saved into session.rawCas
 */

const optsSchema = Joi.object().keys({
  casServerUrl: Joi.string().uri({sheme: ['http', 'https']}).required(),
  casProtocolVersion: Joi.number().valid([1,2,3]).default(2.0),
  casRequestMethod: Joi.string().valid(['GET', 'POST']).default('GET'),
  casAsGateway: Joi.boolean().default(false),
  localAppUrl: Joi.string().uri({scheme: ['http', 'https']}).required(),
  endPointPath: Joi.string().regex(/^\/[\w\W\/]+\/?$/).required(),
  includeHeaders: Joi.array().items(Joi.string()).default(['cookie']),
  strictSSL: Joi.boolean().default(true),
  saveRawCAS: Joi.boolean().default(false)
});

/**
 * &lt;p>Provides an authentication plugin for the Hapi framework that implements
 * CAS authentication. Due to the nature of the CAS protocol, this plugin
 * requires that a session manager plugin be registered with Hapi. This plugin
 * does not provide a session manager on its own. The 'hapi-server-session'
 * plugin is known to work. But any plugin that provides
 * &lt;tt>request.session&lt;/tt> will work.&lt;/p>
 *
 * &lt;p>This plugin is known to work with authentication modes 'required' and
 * 'try'.&lt;/p>
 *
 * @param {object} server A Hapi server instance.
 * @param {PluginOptions} options The options for the CAS authentication plugin.
 * @returns {object} A Hapi authentication scheme object.
 * @throws {AssertionError} When an invalid options object is provided or if
 *  there isn't a session manager registered with the Hapi server.
 */
function casPlugin(server, options) {
  Hoek.assert(options, 'Missing CAS auth scheme options');
  const _options = Joi.validate(options, optsSchema);
  Hoek.assert(_options, 'Options object does not pass schema validation');
  debug('validated options: %j', _options.value);

  const casOptions = {
    serverUrl: _options.value.casServerUrl,
    serviceUrl: _options.value.localAppUrl + _options.value.endPointPath,
    protocolVersion: _options.value.casProtocolVersion,
    method: _options.value.casRequestMethod,
    useGateway: _options.value.casAsGateway,
    strictSSL: _options.value.strictSSL
  };
  const cas = new CAS(casOptions);

  function addHeaders(request, response) {
    for (let h of _options.value.includeHeaders) {
      response.header(h, request.headers[h]);
    }
    return response;
  }

  function gethandler(request, reply) {
    const ticket = request.query.ticket;
    if (!ticket) {
      debug('No ticket query parameter supplied to CAS handler end point');
      const boom = Boom.badRequest('Missing ticket parameter');
      return addHeaders(request, reply(boom));
    }

    return cas.validateServiceTicket(ticket).then(function (result) {
        debug('Service ticket validated:');
        debug('%j', result);
        const redirectPath = request.session.requestPath;
        delete request.session.requestPath;
        request.session.isAuthenticated = true;
        request.session.username = result.user;
        request.session.attributes = result.attributes || {};

        // Save raw cas result for processing by client
        if (_options.value.saveRawCAS) {
          request.session.rawCas = result;
        }

        return addHeaders(request, reply(result)).redirect(redirectPath);
      })
      .catch(function caught(error) {
        debug('Service ticket validation failed:');
        debug('%j', error);
        return addHeaders(request, reply(Boom.forbidden(error.message)));
      });
  }

  server.route({
    method: 'GET',
    path: options.endPointPath,
    handler: gethandler,
    config: {
      auth: false,
      cache: {
        privacy: 'private',
        expiresIn: 0
      }
    }
  });

  const scheme = {};
  scheme.authenticate = function casAuth(request, reply) {
    const session = request.session;
    if (!session) {
      debug('No session provider registered!');
      return reply(Boom.notImplemented(
        'hapi-cas requires a registered Hapi session provider'
      ));
    }

    const credentials = {
      username: session.username,
      attributes: session.attributes
    };
    debug('Credentials: %j', credentials);

    if (session.isAuthenticated) {
      debug('User authenticated by session lookup');
      return reply.continue({credentials: credentials});
    }

    debug('Redirecting auth to: %s', cas.loginUrl);
    session.requestPath = request.path;
    return addHeaders(
      request,
      reply('cas redirect', null, {credentials: credentials})
    )
    .redirect(cas.loginUrl);
  };

  return scheme;
}

/**
 * Standard Hapi plugin registration method. It registers {@link casPlugin}
 * with the scheme name 'cas'.
 *
 * @param {object} server A Hapi server instance.
 * @param {object} options A Hapi plugin registration options object.
 * @param {function} next The Hapi registration finished callback function.
 * @returns {function} The registration finished callback function.
 */
exports.register = function (server, options, next) {
  server.auth.scheme('cas', casPlugin);
  return next();
};

module.exports.register.attributes = {
    pkg: require(__dirname + '/package.json')
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#casPlugin">casPlugin</a></li><li><a href="global.html#register">register</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Tue May 03 2016 20:37:19 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
